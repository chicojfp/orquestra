/*
  Copyright 2014-2016 Sylvain Hallé
  Laboratoire d'informatique formelle
  Université du Québec à Chicoutimi, Canada

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 */
package ca.uqac.lif.bullwinkle.output;

import java.util.ArrayDeque;
import java.util.Deque;

import ca.uqac.lif.bullwinkle.ParseNode;

/**
 * Traverses a parse tree and converts it into a simple XML representation.
 * @author Sylvain Hallé
 */
public class XmlVisitor implements OutputFormatVisitor
{
	/**
	 * A stack keeping the parent nodes
	 */
	private final Deque<String> m_parents;

	/**
	 * A stack keeping the indents
	 */
	private final Deque<String> m_indents;

	/**
	 * A string builder where the output XML is progressively written
	 */
	private final StringBuilder m_output;

	/**
	 * The amount of indentation to add to each nested element
	 */
	private static final String s_indent = "  ";

	/**
	 * The name given to the topmost element of the tree (i.e. the one that
	 * encloses the whole tree)
	 */
	private String m_topElementName = "parsetree";
	
	/**
	 * The element name used to surround leaf tokens
	 */
	private String m_tokenElementName = "token";

	/**
	 * Creates a new XML visitor
	 */
	public XmlVisitor()
	{
		super();
		m_parents = new ArrayDeque<String>();
		m_indents = new ArrayDeque<String>();
		m_output = new StringBuilder();
		m_indents.push("");
	}

	/**
	 * Sets the element name used to surround the XML parse tree
	 * @param name The element name
	 */
	public void setTopElementName(final String name)
	{
		m_topElementName = name;
	}

	/**
	 * Sets the element name used to surround leaf tokens
	 * @param name The element name
	 */
	public void setTokenElementName(final String name)
	{
		m_tokenElementName = name;
	}

	@Override
	public void visit(ParseNode node)
	{
		String label = node.getValue();
		String current_indent = m_indents.peek() + s_indent;
		if (label == null)
		{
			label = node.getToken();
			m_output.append(current_indent).append("<").append(m_tokenElementName).append(">\n");
			m_indents.push(current_indent);
			current_indent = m_indents.peek();
			m_output.append(current_indent).append(label).append("\n");
			m_parents.push(m_tokenElementName);
		}
		else
		{
			// Remove symbols surrounding the name of a rule
			label = label.replace("<", "");
			label = label.replace(">", "");
			m_output.append(current_indent).append("<").append(label).append(">\n");
			m_parents.push(label);
			m_indents.push(current_indent);
		}
	}

	@Override
	public void pop()
	{
		String element_name = m_parents.pop();
		String current_indent = m_indents.pop();
		m_output.append(current_indent).append("</").append(element_name).append(">\n");
	}

	@Override
	public String toOutputString()
	{
		StringBuilder out = new StringBuilder();
		out.append("<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n");
		out.append("<!-- File auto-generated by Bullwinkle -->\n");
		out.append("<").append(m_topElementName).append(">\n").append(m_output).append("</").append(m_topElementName).append(">");
		return out.toString();
	}

}
